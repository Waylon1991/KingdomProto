// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package room

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RoomClient is the client API for Room service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoomClient interface {
	NewRoom(ctx context.Context, in *NewRoomRequest, opts ...grpc.CallOption) (*NewRoomReply, error)
	RoomInfo(ctx context.Context, in *RoomInfoRequest, opts ...grpc.CallOption) (*RoomInfoReply, error)
	CatchCard(ctx context.Context, in *CatchCardRequest, opts ...grpc.CallOption) (*CatchCardReply, error)
	OutCard(ctx context.Context, in *OutCardRequest, opts ...grpc.CallOption) (*OutCardReply, error)
	SellCard(ctx context.Context, in *SellCardRequest, opts ...grpc.CallOption) (*SellCardReply, error)
	UseBuff(ctx context.Context, in *UseBuffRequest, opts ...grpc.CallOption) (*UseBuffReply, error)
	UseSkill(ctx context.Context, in *UseSkillRequest, opts ...grpc.CallOption) (*UseSkillReply, error)
	RollDice(ctx context.Context, in *RollDiceRequest, opts ...grpc.CallOption) (*RollDiceReply, error)
	GiveUpDice(ctx context.Context, in *GiveUpDiceRequest, opts ...grpc.CallOption) (*GiveUpDiceReply, error)
	UseTool(ctx context.Context, in *UseToolRequest, opts ...grpc.CallOption) (*UseToolReply, error)
	SkipStage(ctx context.Context, in *SkipStageRequest, opts ...grpc.CallOption) (*SkipStageReply, error)
}

type roomClient struct {
	cc grpc.ClientConnInterface
}

func NewRoomClient(cc grpc.ClientConnInterface) RoomClient {
	return &roomClient{cc}
}

func (c *roomClient) NewRoom(ctx context.Context, in *NewRoomRequest, opts ...grpc.CallOption) (*NewRoomReply, error) {
	out := new(NewRoomReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/NewRoom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) RoomInfo(ctx context.Context, in *RoomInfoRequest, opts ...grpc.CallOption) (*RoomInfoReply, error) {
	out := new(RoomInfoReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/RoomInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) CatchCard(ctx context.Context, in *CatchCardRequest, opts ...grpc.CallOption) (*CatchCardReply, error) {
	out := new(CatchCardReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/CatchCard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) OutCard(ctx context.Context, in *OutCardRequest, opts ...grpc.CallOption) (*OutCardReply, error) {
	out := new(OutCardReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/OutCard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) SellCard(ctx context.Context, in *SellCardRequest, opts ...grpc.CallOption) (*SellCardReply, error) {
	out := new(SellCardReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/SellCard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) UseBuff(ctx context.Context, in *UseBuffRequest, opts ...grpc.CallOption) (*UseBuffReply, error) {
	out := new(UseBuffReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/UseBuff", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) UseSkill(ctx context.Context, in *UseSkillRequest, opts ...grpc.CallOption) (*UseSkillReply, error) {
	out := new(UseSkillReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/UseSkill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) RollDice(ctx context.Context, in *RollDiceRequest, opts ...grpc.CallOption) (*RollDiceReply, error) {
	out := new(RollDiceReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/RollDice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) GiveUpDice(ctx context.Context, in *GiveUpDiceRequest, opts ...grpc.CallOption) (*GiveUpDiceReply, error) {
	out := new(GiveUpDiceReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/GiveUpDice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) UseTool(ctx context.Context, in *UseToolRequest, opts ...grpc.CallOption) (*UseToolReply, error) {
	out := new(UseToolReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/UseTool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roomClient) SkipStage(ctx context.Context, in *SkipStageRequest, opts ...grpc.CallOption) (*SkipStageReply, error) {
	out := new(SkipStageReply)
	err := c.cc.Invoke(ctx, "/protocol.room.Room/SkipStage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoomServer is the server API for Room service.
// All implementations must embed UnimplementedRoomServer
// for forward compatibility
type RoomServer interface {
	NewRoom(context.Context, *NewRoomRequest) (*NewRoomReply, error)
	RoomInfo(context.Context, *RoomInfoRequest) (*RoomInfoReply, error)
	CatchCard(context.Context, *CatchCardRequest) (*CatchCardReply, error)
	OutCard(context.Context, *OutCardRequest) (*OutCardReply, error)
	SellCard(context.Context, *SellCardRequest) (*SellCardReply, error)
	UseBuff(context.Context, *UseBuffRequest) (*UseBuffReply, error)
	UseSkill(context.Context, *UseSkillRequest) (*UseSkillReply, error)
	RollDice(context.Context, *RollDiceRequest) (*RollDiceReply, error)
	GiveUpDice(context.Context, *GiveUpDiceRequest) (*GiveUpDiceReply, error)
	UseTool(context.Context, *UseToolRequest) (*UseToolReply, error)
	SkipStage(context.Context, *SkipStageRequest) (*SkipStageReply, error)
	mustEmbedUnimplementedRoomServer()
}

// UnimplementedRoomServer must be embedded to have forward compatible implementations.
type UnimplementedRoomServer struct {
}

func (UnimplementedRoomServer) NewRoom(context.Context, *NewRoomRequest) (*NewRoomReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewRoom not implemented")
}
func (UnimplementedRoomServer) RoomInfo(context.Context, *RoomInfoRequest) (*RoomInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoomInfo not implemented")
}
func (UnimplementedRoomServer) CatchCard(context.Context, *CatchCardRequest) (*CatchCardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CatchCard not implemented")
}
func (UnimplementedRoomServer) OutCard(context.Context, *OutCardRequest) (*OutCardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OutCard not implemented")
}
func (UnimplementedRoomServer) SellCard(context.Context, *SellCardRequest) (*SellCardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellCard not implemented")
}
func (UnimplementedRoomServer) UseBuff(context.Context, *UseBuffRequest) (*UseBuffReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseBuff not implemented")
}
func (UnimplementedRoomServer) UseSkill(context.Context, *UseSkillRequest) (*UseSkillReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseSkill not implemented")
}
func (UnimplementedRoomServer) RollDice(context.Context, *RollDiceRequest) (*RollDiceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollDice not implemented")
}
func (UnimplementedRoomServer) GiveUpDice(context.Context, *GiveUpDiceRequest) (*GiveUpDiceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GiveUpDice not implemented")
}
func (UnimplementedRoomServer) UseTool(context.Context, *UseToolRequest) (*UseToolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseTool not implemented")
}
func (UnimplementedRoomServer) SkipStage(context.Context, *SkipStageRequest) (*SkipStageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SkipStage not implemented")
}
func (UnimplementedRoomServer) mustEmbedUnimplementedRoomServer() {}

// UnsafeRoomServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoomServer will
// result in compilation errors.
type UnsafeRoomServer interface {
	mustEmbedUnimplementedRoomServer()
}

func RegisterRoomServer(s grpc.ServiceRegistrar, srv RoomServer) {
	s.RegisterService(&Room_ServiceDesc, srv)
}

func _Room_NewRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).NewRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/NewRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).NewRoom(ctx, req.(*NewRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_RoomInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).RoomInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/RoomInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).RoomInfo(ctx, req.(*RoomInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_CatchCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CatchCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).CatchCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/CatchCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).CatchCard(ctx, req.(*CatchCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_OutCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).OutCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/OutCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).OutCard(ctx, req.(*OutCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_SellCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).SellCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/SellCard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).SellCard(ctx, req.(*SellCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_UseBuff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UseBuffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).UseBuff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/UseBuff",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).UseBuff(ctx, req.(*UseBuffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_UseSkill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UseSkillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).UseSkill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/UseSkill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).UseSkill(ctx, req.(*UseSkillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_RollDice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollDiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).RollDice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/RollDice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).RollDice(ctx, req.(*RollDiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_GiveUpDice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GiveUpDiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).GiveUpDice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/GiveUpDice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).GiveUpDice(ctx, req.(*GiveUpDiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_UseTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UseToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).UseTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/UseTool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).UseTool(ctx, req.(*UseToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Room_SkipStage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkipStageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoomServer).SkipStage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.room.Room/SkipStage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoomServer).SkipStage(ctx, req.(*SkipStageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Room_ServiceDesc is the grpc.ServiceDesc for Room service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Room_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.room.Room",
	HandlerType: (*RoomServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewRoom",
			Handler:    _Room_NewRoom_Handler,
		},
		{
			MethodName: "RoomInfo",
			Handler:    _Room_RoomInfo_Handler,
		},
		{
			MethodName: "CatchCard",
			Handler:    _Room_CatchCard_Handler,
		},
		{
			MethodName: "OutCard",
			Handler:    _Room_OutCard_Handler,
		},
		{
			MethodName: "SellCard",
			Handler:    _Room_SellCard_Handler,
		},
		{
			MethodName: "UseBuff",
			Handler:    _Room_UseBuff_Handler,
		},
		{
			MethodName: "UseSkill",
			Handler:    _Room_UseSkill_Handler,
		},
		{
			MethodName: "RollDice",
			Handler:    _Room_RollDice_Handler,
		},
		{
			MethodName: "GiveUpDice",
			Handler:    _Room_GiveUpDice_Handler,
		},
		{
			MethodName: "UseTool",
			Handler:    _Room_UseTool_Handler,
		},
		{
			MethodName: "SkipStage",
			Handler:    _Room_SkipStage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "room/room.proto",
}
